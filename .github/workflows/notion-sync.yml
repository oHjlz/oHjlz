name: Sync Notion to README

on:
  schedule:
    - cron: '0 */6 * * *'  # Every 6 hours
  workflow_dispatch:  # Manual trigger button
  push:
    paths:
      - '.github/workflows/notion-sync.yml'  # Run when workflow is updated

jobs:
  sync-notion:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Create sync script
        run: |
          cat > sync-notion.js << 'EOF'
          const https = require('https');
          const fs = require('fs');

          function makeRequest(options, postData = null) {
            return new Promise((resolve, reject) => {
              const req = https.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => data += chunk);
                res.on('end', () => {
                  try {
                    resolve(JSON.parse(data));
                  } catch (e) {
                    resolve(data);
                  }
                });
              });
              req.on('error', reject);
              if (postData) req.write(JSON.stringify(postData));
              req.end();
            });
          }

          async function getNotionBlocks(pageId, token, startCursor = null) {
            const options = {
              hostname: 'api.notion.com',
              port: 443,
              path: `/v1/blocks/${pageId}/children${startCursor ? `?start_cursor=${startCursor}` : ''}`,
              method: 'GET',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Notion-Version': '2022-06-28',
                'Content-Type': 'application/json'
              }
            };

            return await makeRequest(options);
          }

          async function queryDatabase(databaseId, token) {
            const options = {
              hostname: 'api.notion.com',
              port: 443,
              path: `/v1/databases/${databaseId}/query`,
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Notion-Version': '2022-06-28',
                'Content-Type': 'application/json',
                'User-Agent': 'GitHub-Action-Sync'
              }
            };
            
            const requestBody = {
              sorts: []
            };
            
            return await makeRequest(options, requestBody);
          }

          async function getDatabaseSchema(databaseId, token) {
            const options = {
              hostname: 'api.notion.com',
              port: 443,
              path: `/v1/databases/${databaseId}`,
              method: 'GET',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Notion-Version': '2022-06-28',
                'Content-Type': 'application/json',
                'User-Agent': 'GitHub-Action-Sync'
              }
            };
            return await makeRequest(options);
          }

          function formatPropertyValue(property) {
            if (!property) return '';
            
            switch (property.type) {
              case 'title':
                return property.title.map(t => t.plain_text).join('').trim();
              case 'rich_text':
                return property.rich_text.map(t => {
                  let content = t.plain_text;
                  if (t.annotations.bold) content = `**${content}**`;
                  if (t.annotations.italic) content = `*${content}*`;
                  if (t.annotations.code) content = `\`${content}\``;
                  if (t.href) content = `[${content}](${t.href})`;
                  return content;
                }).join('').trim();
              case 'number':
                return property.number ? property.number.toString() : '';
              case 'select':
                return property.select ? property.select.name : '';
              case 'multi_select':
                return property.multi_select.map(s => s.name).join(', ');
              case 'date':
                if (property.date) {
                  const date = new Date(property.date.start);
                  return date.toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'short', 
                    day: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit',
                    hour12: true
                  });
                }
                return '';
              case 'checkbox':
                return property.checkbox ? '‚úÖ' : '‚ùå';
              case 'url':
                return property.url ? `[Link](${property.url})` : '';
              case 'email':
                return property.email ? `[${property.email}](mailto:${property.email})` : '';
              case 'phone_number':
                return property.phone_number || '';
              case 'status':
                return property.status ? property.status.name : '';
              case 'formula':
                if (property.formula) {
                  switch (property.formula.type) {
                    case 'string':
                      return property.formula.string || '';
                    case 'number':
                      return property.formula.number ? property.formula.number.toString() : '';
                    case 'boolean':
                      return property.formula.boolean ? '‚úÖ' : '‚ùå';
                    case 'date':
                      return property.formula.date ? property.formula.date.start : '';
                    default:
                      return '';
                  }
                }
                return '';
              default:
                return '';
            }
          }

          function isRowCompleted(row, headers) {
            for (const header of headers) {
              const headerLower = header.toLowerCase();
              if (headerLower.includes('done') || 
                  headerLower.includes('completed') || 
                  headerLower.includes('check') ||
                  headerLower.includes('finish')) {
                const value = row[header] || '';
                if (value === '‚úÖ' || value.toLowerCase() === 'true' || 
                    value.includes('‚úì') || value.includes('‚òë')) {
                  return true;
                }
              }
            }
            
            const progressValue = row['Progress'] || '';
            if (progressValue.includes('100%') || progressValue.includes('‚úÖ') || 
                progressValue.toLowerCase().includes('complete')) {
              return true;
            }
            
            for (const [key, value] of Object.entries(row)) {
              const valueStr = String(value).toLowerCase();
              if (valueStr.includes('complete') || valueStr.includes('‚úÖ') || 
                  valueStr.includes('done') || valueStr === 'true') {
                return true;
              }
            }
            
            return false;
          }

          function getDifficultyBadge(difficulty) {
            const difficultyStr = difficulty.toLowerCase().trim();
            switch(difficultyStr) {
              case 'easy':
                return 'üü¢ Easy';
              case 'medium':
                return 'üü° Medium';
              case 'hard':
                return 'üî¥ Hard';
              default:
                return difficulty;
            }
          }

          async function syncNotion() {
            const token = process.env.NOTION_TOKEN;
            const pageId = process.env.NOTION_PAGE_ID || process.env.NOTION_DATABASE_ID;
            
            console.log('Environment check:');
            console.log('- NOTION_TOKEN exists:', !!token);
            console.log('- NOTION_PAGE_ID exists:', !!process.env.NOTION_PAGE_ID);
            console.log('- Using Page ID:', pageId ? pageId.substring(0, 8) + '...' : 'MISSING');
            
            if (!token || !pageId) {
              console.error('‚ùå Missing required environment variables');
              process.exit(1);
            }

            try {
              console.log('Fetching Notion page content...');
              
              let allBlocks = [];
              let hasMore = true;
              let startCursor = null;

              while (hasMore) {
                const response = await getNotionBlocks(pageId, token, startCursor);
                
                if (response.results) {
                  allBlocks = allBlocks.concat(response.results);
                  hasMore = response.has_more;
                  startCursor = response.next_cursor;
                } else {
                  console.error('Error fetching blocks:', response);
                  process.exit(1);
                }
              }

              console.log(`Found ${allBlocks.length} blocks on the page`);

              let completedData = [];
              let allData = [];
              let headers = [];
              
              for (const block of allBlocks) {
                if (block.type === 'child_database') {
                  console.log('‚úÖ Found database - querying...');
                  
                  const dbSchema = await getDatabaseSchema(block.id, token);
                  const dbData = await queryDatabase(block.id, token);
                  
                  if (dbData.results && dbData.results.length > 0) {
                    const propertyNames = Object.keys(dbSchema.properties || {});
                    headers = propertyNames;
                    
                    dbData.results.forEach((entry) => {
                      const rowData = {};
                      propertyNames.forEach(propName => {
                        rowData[propName] = formatPropertyValue(entry.properties[propName]);
                      });
                      
                      allData.push(rowData);
                      
                      if (isRowCompleted(rowData, propertyNames)) {
                        completedData.push(rowData);
                      }
                    });
                    
                    break;
                  }
                }
              }

              let markdown = '## üìä Progress Dashboard\n\n';
              
              if (completedData.length > 0) {
                markdown += `**Completed:** ${completedData.length} items\n\n`;
              } else {
                markdown += `**Total Items:** ${allData.length}\n\n`;
              }

              const dataToShow = completedData.length > 0 ? completedData : allData;
              
              if (dataToShow.length > 0 && headers.length > 0) {
                const relevantColumns = headers.filter(h => h !== 'Property');
                
                markdown += '| ' + relevantColumns.join(' | ') + ' |\n';
                markdown += '| ' + relevantColumns.map(() => '---').join(' | ') + ' |\n';

                dataToShow.forEach(row => {
                  const rowData = relevantColumns.map(col => {
                    let value = row[col] || '';
                    if (col.toLowerCase().includes('difficulty') && value) {
                      value = getDifficultyBadge(value);
                    }
                    return value.replace(/\|/g, '\\|') || '-';
                  });
                  
                  markdown += '| ' + rowData.join(' | ') + ' |\n';
                });
              }

              const now = new Date();
              const lastUpdated = now.toLocaleString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: 'numeric',
                minute: '2-digit',
                hour12: true,
                timeZone: 'America/New_York'
              });
              
              markdown += `\n---\n\n*üìÖ Last synced: ${lastUpdated} EST*\n`;

              let readme = '';
              if (fs.existsSync('README.md')) {
                readme = fs.readFileSync('README.md', 'utf8');
              } else {
                readme = '# Welcome to my GitHub Profile!\n\n';
              }

              const startMarker = '<!-- NOTION-SYNC-START -->';
              const endMarker = '<!-- NOTION-SYNC-END -->';
              
              const startIndex = readme.indexOf(startMarker);
              const endIndex = readme.indexOf(endMarker);

              if (startIndex !== -1 && endIndex !== -1) {
                const before = readme.substring(0, startIndex + startMarker.length);
                const after = readme.substring(endIndex);
                readme = before + '\n\n' + markdown + '\n' + after;
              } else {
                readme += `\n\n${startMarker}\n\n${markdown}\n${endMarker}\n`;
              }

              fs.writeFileSync('README.md', readme);
              console.log('‚úÖ README updated successfully!');

            } catch (error) {
              console.error('‚ùå Error syncing Notion:', error.message);
              process.exit(1);
            }
          }

          syncNotion();
          EOF
          
      - name: Sync Notion content
        env:
          NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}
          NOTION_DATABASE_ID: ${{ secrets.NOTION_DATABASE_ID }}
          NOTION_PAGE_ID: ${{ secrets.NOTION_PAGE_ID }}
        run: node sync-notion.js
        
      - name: Commit and push changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add README.md
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "üîÑ Auto-sync progress - $(date '+%Y-%m-%d %H:%M')"
            git push
            echo "‚úÖ Changes pushed to repository"
          fi

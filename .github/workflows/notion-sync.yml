# .github/workflows/notion-sync.yml
name: Sync Notion to README

on:
  schedule:
    - cron: '0 */6 * * *'  # Every 6 hours
  workflow_dispatch:  # Manual trigger button
  push:
    paths:
      - '.github/workflows/notion-sync.yml'  # Run when workflow is updated

jobs:
  sync-notion:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Create sync script
        run: |
          cat > sync-notion.js << 'EOF'
          const https = require('https');
          const fs = require('fs');

          function makeRequest(options, postData = null) {
            return new Promise((resolve, reject) => {
              const req = https.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => data += chunk);
                res.on('end', () => {
                  try {
                    resolve(JSON.parse(data));
                  } catch (e) {
                    resolve(data);
                  }
                });
              });
              req.on('error', reject);
              if (postData) req.write(JSON.stringify(postData));
              req.end();
            });
          }

          async function getNotionBlocks(pageId, token, startCursor = null) {
            const options = {
              hostname: 'api.notion.com',
              port: 443,
              path: `/v1/blocks/${pageId}/children${startCursor ? `?start_cursor=${startCursor}` : ''}`,
              method: 'GET',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Notion-Version': '2022-06-28',
                'Content-Type': 'application/json'
              }
            };

            return await makeRequest(options);
          }

          function formatRichText(richText) {
            return richText.map(text => {
              let content = text.plain_text;
              if (text.annotations.bold) content = `**${content}**`;
              if (text.annotations.italic) content = `*${content}*`;
              if (text.annotations.code) content = `\`${content}\``;
              if (text.annotations.strikethrough) content = `~~${content}~~`;
              if (text.href) content = `[${content}](${text.href})`;
              return content;
            }).join('');
          }

          async function getTableRows(tableId, token) {
            const options = {
              hostname: 'api.notion.com',
              port: 443,
              path: `/v1/blocks/${tableId}/children`,
              method: 'GET',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Notion-Version': '2022-06-28',
                'Content-Type': 'application/json',
                'User-Agent': 'GitHub-Action-Sync'
              }
            };
            return await makeRequest(options);
          }

          async function convertBlockToMarkdown(block, token) {
            switch (block.type) {
              case 'paragraph':
                return formatRichText(block.paragraph.rich_text) + '\n\n';
                
              case 'heading_1':
                return '# ' + formatRichText(block.heading_1.rich_text) + '\n\n';
                
              case 'heading_2':
                return '## ' + formatRichText(block.heading_2.rich_text) + '\n\n';
                
              case 'heading_3':
                return '### ' + formatRichText(block.heading_3.rich_text) + '\n\n';
                
              case 'bulleted_list_item':
                return '- ' + formatRichText(block.bulleted_list_item.rich_text) + '\n';
                
              case 'numbered_list_item':
                return '1. ' + formatRichText(block.numbered_list_item.rich_text) + '\n';
                
              case 'to_do':
                const checked = block.to_do.checked ? '[x]' : '[ ]';
                return `- ${checked} ` + formatRichText(block.to_do.rich_text) + '\n';
                
              case 'code':
                const language = block.code.language || '';
                const codeText = formatRichText(block.code.rich_text);
                return `\`\`\`${language}\n${codeText}\n\`\`\`\n\n`;
                
              case 'quote':
                return '> ' + formatRichText(block.quote.rich_text) + '\n\n';
                
              case 'callout':
                const emoji = block.callout.icon?.emoji || '💡';
                return `${emoji} **${formatRichText(block.callout.rich_text)}**\n\n`;
                
              case 'divider':
                return '---\n\n';
                
              case 'table':
                try {
                  const tableData = await getTableRows(block.id, token);
                  if (!tableData.results || tableData.results.length === 0) {
                    return '| Table | Content | Not | Available |\n|-------|---------|-----|----------|\n\n';
                  }
                  
                  let tableMarkdown = '';
                  const rows = tableData.results;
                  
                  // Process table rows
                  for (let i = 0; i < rows.length; i++) {
                    const row = rows[i];
                    if (row.type === 'table_row' && row.table_row && row.table_row.cells) {
                      const cells = row.table_row.cells.map(cell => 
                        formatRichText(cell).replace(/\|/g, '\\|').trim() || ' '
                      );
                      tableMarkdown += '| ' + cells.join(' | ') + ' |\n';
                      
                      // Add header separator after first row
                      if (i === 0) {
                        const separators = cells.map(() => '---');
                        tableMarkdown += '| ' + separators.join(' | ') + ' |\n';
                      }
                    }
                  }
                  
                  return tableMarkdown + '\n';
                } catch (error) {
                  console.log('Error processing table:', error);
                  return '**[Table content - view in Notion for full details]**\n\n';
                }
                
              case 'embed':
                if (block.embed && block.embed.url) {
                  return `[Embedded Content](${block.embed.url})\n\n`;
                }
                return '**[Embedded content - view in Notion]**\n\n';
                
              case 'image':
                if (block.image && (block.image.file?.url || block.image.external?.url)) {
                  const imageUrl = block.image.file?.url || block.image.external?.url;
                  const caption = block.image.caption ? formatRichText(block.image.caption) : '';
                  return `![${caption}](${imageUrl})\n${caption ? `*${caption}*\n` : ''}\n`;
                }
                return '**[Image - view in Notion]**\n\n';
                
              default:
                // Handle unknown blocks gracefully
                if (block[block.type] && block[block.type].rich_text) {
                  return formatRichText(block[block.type].rich_text) + '\n\n';
                }
                console.log(`Unsupported block type: ${block.type}`);
                return `**[${block.type.replace('_', ' ').toUpperCase()} - view in Notion for full content]**\n\n`;
            }
          }

          async function syncNotion() {
            const token = process.env.NOTION_TOKEN;
            const pageId = process.env.NOTION_PAGE_ID;
            
            if (!token || !pageId) {
              console.error('Missing NOTION_TOKEN or NOTION_PAGE_ID');
              process.exit(1);
            }

            try {
              console.log('Fetching Notion content...');
              let allBlocks = [];
              let hasMore = true;
              let startCursor = null;

              while (hasMore) {
                const response = await getNotionBlocks(pageId, token, startCursor);
                
                if (response.results) {
                  allBlocks = allBlocks.concat(response.results);
                  hasMore = response.has_more;
                  startCursor = response.next_cursor;
                } else {
                  console.error('Error fetching blocks:', response);
                  process.exit(1);
                }
              }

              let markdown = '';
              for (const block of allBlocks) {
                markdown += await convertBlockToMarkdown(block, token);
              }

              // Add metadata
              const now = new Date();
              const lastUpdated = now.toISOString().split('T')[0];
              markdown += `\n---\n\n*📅 Last synced: ${lastUpdated}*\n`;

              // Read existing README or create new one
              let readme = '';
              if (fs.existsSync('README.md')) {
                readme = fs.readFileSync('README.md', 'utf8');
              } else {
                readme = '# Welcome to my GitHub Profile!\n\n';
              }

              // Update content between markers
              const startMarker = '<!-- NOTION-SYNC-START -->';
              const endMarker = '<!-- NOTION-SYNC-END -->';
              
              const startIndex = readme.indexOf(startMarker);
              const endIndex = readme.indexOf(endMarker);

              if (startIndex !== -1 && endIndex !== -1) {
                const before = readme.substring(0, startIndex + startMarker.length);
                const after = readme.substring(endIndex);
                readme = before + '\n\n' + markdown + '\n' + after;
              } else {
                const header = `\n\n## 🧠 Blind 75 LeetCode Progress\n\n${startMarker}\n\n`;
                const footer = `\n${endMarker}\n`;
                readme += header + markdown + footer;
              }

              fs.writeFileSync('README.md', readme);
              console.log('✅ README updated successfully!');

            } catch (error) {
              console.error('❌ Error syncing Notion:', error.message);
              process.exit(1);
            }
          }

          syncNotion();
          EOF
          
      - name: Sync Notion content
        env:
          NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}
          NOTION_PAGE_ID: ${{ secrets.NOTION_PAGE_ID }}
        run: node sync-notion.js
        
      - name: Commit and push changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add README.md
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "🔄 Auto-sync Notion content - $(date '+%Y-%m-%d %H:%M')"
            git push
            echo "✅ Changes pushed to repository"
          fi

const https = require('https');
const fs = require('fs');

function makeRequest(options, postData = null) {
  return new Promise((resolve, reject) => {
    const req = https.request(options, (res) => {
      let data = '';
      res.on('data', (chunk) => data += chunk);
      res.on('end', () => {
        try {
          resolve(JSON.parse(data));
        } catch (e) {
          resolve(data);
        }
      });
    });
    req.on('error', reject);
    if (postData) req.write(JSON.stringify(postData));
    req.end();
  });
}

async function getNotionBlocks(pageId, token, startCursor = null) {
  const options = {
    hostname: 'api.notion.com',
    port: 443,
    path: `/v1/blocks/${pageId}/children${startCursor ? `?start_cursor=${startCursor}` : ''}`,
    method: 'GET',
    headers: {
      'Authorization': `Bearer ${token}`,
      'Notion-Version': '2022-06-28',
      'Content-Type': 'application/json'
    }
  };
  return await makeRequest(options);
}

async function getTableRows(tableId, token) {
  const options = {
    hostname: 'api.notion.com',
    port: 443,
    path: `/v1/blocks/${tableId}/children`,
    method: 'GET',
    headers: {
      'Authorization': `Bearer ${token}`,
      'Notion-Version': '2022-06-28',
      'Content-Type': 'application/json'
    }
  };
  return await makeRequest(options);
}

function extractTextFromRichText(richTextArray) {
  if (!richTextArray || !Array.isArray(richTextArray)) return '';
  
  return richTextArray.map(item => {
    let text = item.plain_text || '';
    if (item.annotations?.bold) text = `**${text}**`;
    if (item.annotations?.italic) text = `*${text}*`;
    if (item.annotations?.code) text = `\`${text}\``;
    if (item.href) text = `[${text}](${item.href})`;
    return text;
  }).join('').trim();
}

function getDifficultyBadge(difficulty) {
  if (!difficulty) return '';
  const diff = difficulty.toLowerCase().trim();
  switch(diff) {
    case 'easy': return 'üü¢ Easy';
    case 'medium': return 'üü° Medium';
    case 'hard': return 'üî¥ Hard';
    default: return difficulty;
  }
}

function getTopicBadge(topic) {
  if (!topic) return '';
  const topicEmojis = {
    'Arrays': 'üìä',
    'Strings': 'üî§', 
    'Linked Lists': 'üîó',
    'Trees': 'üå≥',
    'Graphs': 'üï∏Ô∏è',
    'Dynamic Programming': '‚ö°',
    'Hash Tables': '#Ô∏è‚É£',
    'Two Pointers': 'üëâüëà',
    'Sliding Window': 'ü™ü'
  };
  return topicEmojis[topic] ? `${topicEmojis[topic]} ${topic}` : topic;
}

async function syncNotion() {
  const token = process.env.NOTION_TOKEN;
  const pageId = process.env.NOTION_PAGE_ID;
  
  console.log('üîÑ Starting LeetCode progress sync...');
  console.log('- NOTION_TOKEN exists:', !!token);
  console.log('- NOTION_PAGE_ID exists:', !!pageId);
  
  if (!token || !pageId) {
    console.error('‚ùå Missing NOTION_TOKEN or NOTION_PAGE_ID');
    process.exit(1);
  }

  try {
    // Get all blocks from the Notion page
    console.log('üìñ Fetching Notion page content...');
    const response = await getNotionBlocks(pageId, token);
    
    if (!response.results) {
      console.error('‚ùå Failed to fetch page blocks');
      process.exit(1);
    }

    console.log(`üìÑ Found ${response.results.length} blocks`);

    // Look for both databases AND tables
    let dataSource = null;
    let dataType = null;
    
    for (const block of response.results) {
      console.log(`üîç Block type: ${block.type}, ID: ${block.id.substring(0, 8)}...`);
      
      if (block.type === 'child_database') {
        dataSource = block.id;
        dataType = 'database';
        console.log('üóÑÔ∏è Found database:', dataSource.substring(0, 8) + '...');
        break;
      } else if (block.type === 'table') {
        dataSource = block.id;
        dataType = 'table';
        console.log('üìã Found table:', dataSource.substring(0, 8) + '...');
        console.log('üìä Table has', block.table?.table_width || 'unknown', 'columns');
        break;
      }
    }

    if (!dataSource) {
      console.error('‚ùå No database or table found on the page');
      console.log('Available block types:', response.results.map(b => b.type));
      process.exit(1);
    }

    if (dataType === 'table') {
      // Handle table blocks
      console.log('üìã Processing table data...');
      const tableData = await getTableRows(dataSource, token);
      
      if (!tableData.results || tableData.results.length === 0) {
        console.log('‚ö†Ô∏è No rows found in table');
        return;
      }

      console.log(`üìà Table has ${tableData.results.length} rows`);

      // Extract header row (first row) to understand column structure
      const headerRow = tableData.results[0];
      if (!headerRow || headerRow.type !== 'table_row') {
        console.error('‚ùå First row is not a table_row');
        return;
      }

      const headers = headerRow.table_row.cells.map(cell => 
        extractTextFromRichText(cell).toLowerCase().trim()
      );
      
      console.log('üìù Table headers:', headers);

      // Process data rows (skip header)
      const completedProblems = [];
      const dataRows = tableData.results.slice(1);

      dataRows.forEach((row, index) => {
        if (row.type !== 'table_row') return;

        console.log(`\n--- Processing Row ${index + 1} ---`);
        const rowData = {};
        
        row.table_row.cells.forEach((cell, cellIndex) => {
          const headerName = headers[cellIndex] || `column_${cellIndex}`;
          const cellValue = extractTextFromRichText(cell);
          rowData[headerName] = cellValue;
          console.log(`  ${headerName}: "${cellValue}"`);
        });

        // Check if this row should be included
        let shouldInclude = false;
        let includeReason = '';

        // Method 1: Check for "done" or "completed" column with checkmarks
        const doneColumns = ['done', 'completed', 'complete', 'finished', 'status'];
        for (const colName of doneColumns) {
          const value = rowData[colName] || '';
          if (value.includes('‚úÖ') || value.includes('‚òë') || value.includes('‚úì') || 
              value.toLowerCase().includes('done') || value.toLowerCase().includes('complete')) {
            shouldInclude = true;
            includeReason = `${colName} column indicates completion`;
            break;
          }
        }

        // Method 2: Check if problem name exists
        const problemColumns = ['problem', 'problem name', 'name', 'title'];
        for (const colName of problemColumns) {
          const value = rowData[colName] || '';
          if (value.trim().length > 0) {
            shouldInclude = true;
            includeReason = includeReason ? includeReason + ' AND has problem name' : 'Has problem name';
            break;
          }
        }

        // Method 3: Check for any checkmark symbols in any column
        Object.entries(rowData).forEach(([colName, value]) => {
          if (value && (value.includes('‚úÖ') || value.includes('‚òë') || value.includes('‚úì'))) {
            shouldInclude = true;
            includeReason = includeReason ? includeReason + ` AND ${colName} has checkmark` : `${colName} has checkmark symbol`;
          }
        });

        console.log(`  Decision: ${shouldInclude ? '‚úÖ INCLUDE' : '‚ùå SKIP'}`);
        if (includeReason) {
          console.log(`  Reason: ${includeReason}`);
        }

        if (shouldInclude) {
          // Map common column names to expected format
          const mappedRow = {};
          Object.entries(rowData).forEach(([key, value]) => {
            const lowerKey = key.toLowerCase();
            if (lowerKey.includes('problem') || lowerKey.includes('name') || lowerKey.includes('title')) {
              mappedRow['Problem Name & Link'] = value;
            } else if (lowerKey.includes('difficulty')) {
              mappedRow['Difficulty'] = value;
            } else if (lowerKey.includes('topic') || lowerKey.includes('category')) {
              mappedRow['Topic'] = value;
            } else if (lowerKey.includes('language')) {
              mappedRow['Languages'] = value;
            } else if (lowerKey.includes('day')) {
              mappedRow['Day'] = value;
            } else if (lowerKey.includes('date')) {
              mappedRow['Date Edited / Completed'] = value;
            } else if (lowerKey.includes('complexity')) {
              mappedRow['Time & Space Complexity'] = value;
            } else {
              mappedRow[key] = value;
            }
          });
          
          completedProblems.push(mappedRow);
        }
      });

      console.log(`üéØ Found ${completedProblems.length} completed problems out of ${dataRows.length} total`);

      if (completedProblems.length === 0) {
        console.log('‚ö†Ô∏è No problems found matching our criteria');
        console.log('üí° For tables, we look for rows that:');
        console.log('   1. Have ‚úÖ ‚òë ‚úì checkmarks in any column, OR');
        console.log('   2. Have "done"/"complete" text in status columns, OR');
        console.log('   3. Have content in problem/name columns');
        console.log('');
        console.log('üîß Try adding checkmarks (‚úÖ) to completed problems!');
        return;
      }

      // Build the markdown table (same as before)
      let markdown = '## üß† LeetCode Progress - Blind 75\n\n';
      
      const totalProblems = 75;
      const completed = completedProblems.length;
      const progressPercent = Math.round((completed / totalProblems) * 100);
      
      markdown += `**Progress:** ${completed}/${totalProblems} problems completed (${progressPercent}%)\n\n`;

      // Count by difficulty
      const difficultyCount = { easy: 0, medium: 0, hard: 0 };
      completedProblems.forEach(problem => {
        const diff = (problem['Difficulty'] || '').toLowerCase();
        if (difficultyCount.hasOwnProperty(diff)) {
          difficultyCount[diff]++;
        }
      });

      markdown += `**By Difficulty:** üü¢ ${difficultyCount.easy} Easy | üü° ${difficultyCount.medium} Medium | üî¥ ${difficultyCount.hard} Hard\n\n`;

      // Create the table
      const columns = [
        { key: 'Day', display: 'Day', width: 'small' },
        { key: 'Problem Name & Link', display: 'Problem', width: 'large' },
        { key: 'Topic', display: 'Topic', width: 'medium' },
        { key: 'Difficulty', display: 'Difficulty', width: 'small' },
        { key: 'Time & Space Complexity', display: 'Complexity', width: 'medium' },
        { key: 'Languages', display: 'Languages', width: 'small' },
        { key: 'Date Edited / Completed', display: 'Date', width: 'small' }
      ];

      // Filter columns that exist in the data
      const availableColumns = columns.filter(col => 
        completedProblems.some(row => row[col.key] && row[col.key].trim())
      );

      if (availableColumns.length === 0) {
        // Fallback: show all available columns
        const allKeys = [...new Set(completedProblems.flatMap(row => Object.keys(row)))];
        availableColumns.push(...allKeys.map(key => ({ key, display: key, width: 'medium' })));
      }

      // Create table header
      markdown += '| ' + availableColumns.map(col => col.display).join(' | ') + ' |\n';
      markdown += '| ' + availableColumns.map(col => {
        switch(col.width) {
          case 'small': return ':---:';
          case 'large': return ':---';
          default: return '---';
        }
      }).join(' | ') + ' |\n';

      // Add data rows
      completedProblems.forEach(problem => {
        const rowData = availableColumns.map(col => {
          let value = problem[col.key] || '';
          
          // Apply special formatting
          if (col.key === 'Difficulty') {
            value = getDifficultyBadge(value);
          } else if (col.key === 'Topic') {
            value = getTopicBadge(value);
          } else if (col.key === 'Languages' && value) {
            value = value.split(',').map(lang => `\`${lang.trim()}\``).join(' ');
          } else if (col.key === 'Problem Name & Link' && value && value.length > 50) {
            value = value.substring(0, 47) + '...';
          }
          
          return (value || '').replace(/\|/g, '\\|').trim() || '-';
        });
        
        markdown += '| ' + rowData.join(' | ') + ' |\n';
      });

      // Add footer
      const now = new Date();
      const timestamp = now.toLocaleString('en-US', {
        year: 'numeric', month: 'short', day: 'numeric',
        hour: 'numeric', minute: '2-digit', hour12: true,
        timeZone: 'America/New_York'
      });
      
      const remaining = totalProblems - completed;
      markdown += `\n---\n\n*üìÖ Last updated: ${timestamp} EST*  \n`;
      markdown += `*üéØ ${remaining} problems remaining to complete the Blind 75!*\n`;

      // Update README.md
      let readme = '';
      if (fs.existsSync('README.md')) {
        readme = fs.readFileSync('README.md', 'utf8');
      } else {
        readme = '# My Coding Journey\n\n';
      }

      const startMarker = '<!-- NOTION-SYNC-START -->';
      const endMarker = '<!-- NOTION-SYNC-END -->';
      
      const startIndex = readme.indexOf(startMarker);
      const endIndex = readme.indexOf(endMarker);

      if (startIndex !== -1 && endIndex !== -1) {
        const before = readme.substring(0, startIndex + startMarker.length);
        const after = readme.substring(endIndex);
        readme = before + '\n\n' + markdown + '\n' + after;
      } else {
        readme += `\n\n${startMarker}\n\n${markdown}\n${endMarker}\n`;
      }

      fs.writeFileSync('README.md', readme);
      console.log('‚úÖ README.md updated successfully!');
      console.log(`üìä Added ${completed} completed LeetCode problems to README`);

    } else {
      // Handle database blocks (original code)
      console.log('üóÑÔ∏è This is a database - use the original script logic');
      // ... original database code would go here
    }

  } catch (error) {
    console.error('‚ùå Error:', error.message);
    console.error('Stack:', error.stack);
    process.exit(1);
  }
}

syncNotion();

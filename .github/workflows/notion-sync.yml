# .github/workflows/notion-sync.yml
name: Sync Notion to README

on:
  schedule:
    - cron: '0 */6 * * *'  # Every 6 hours
  workflow_dispatch:  # Manual trigger button
  push:
    paths:
      - '.github/workflows/notion-sync.yml'  # Run when workflow is updated

jobs:
  sync-notion:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Create sync script
        run: |
          cat > sync-notion.js << 'EOF'
          const https = require('https');
          const fs = require('fs');

          function makeRequest(options, postData = null) {
            return new Promise((resolve, reject) => {
              const req = https.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => data += chunk);
                res.on('end', () => {
                  try {
                    resolve(JSON.parse(data));
                  } catch (e) {
                    resolve(data);
                  }
                });
              });
              req.on('error', reject);
              if (postData) req.write(JSON.stringify(postData));
              req.end();
            });
          }

          async function getNotionBlocks(pageId, token, startCursor = null) {
            const options = {
              hostname: 'api.notion.com',
              port: 443,
              path: `/v1/blocks/${pageId}/children${startCursor ? `?start_cursor=${startCursor}` : ''}`,
              method: 'GET',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Notion-Version': '2022-06-28',
                'Content-Type': 'application/json'
              }
            };

            return await makeRequest(options);
          }

          async function getChildBlocks(blockId, token) {
            const options = {
              hostname: 'api.notion.com',
              port: 443,
              path: `/v1/blocks/${blockId}/children`,
              method: 'GET',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Notion-Version': '2022-06-28',
                'Content-Type': 'application/json',
                'User-Agent': 'GitHub-Action-Sync'
              }
            };
            return await makeRequest(options);
          }

          function formatRichText(richText) {
            if (!richText || !Array.isArray(richText)) return '';
            return richText.map(text => {
              let content = text.plain_text;
              if (text.annotations.bold) content = `**${content}**`;
              if (text.annotations.italic) content = `*${content}*`;
              if (text.annotations.code) content = `\`${content}\``;
              if (text.annotations.strikethrough) content = `~~${content}~~`;
              if (text.href) content = `[${content}](${text.href})`;
              return content;
            }).join('');
          }

          function getDifficultyBadge(difficulty) {
            const difficultyStr = difficulty.toLowerCase().trim();
            switch(difficultyStr) {
              case 'easy':
                return 'üü¢ Easy';
              case 'medium':
                return 'üü° Medium';
              case 'hard':
                return 'üî¥ Hard';
              default:
                return difficulty;
            }
          }

          function getTopicBadge(topic) {
            const topicEmojis = {
              'Arrays': 'üìä',
              'Strings': 'üî§',
              'Linked Lists': 'üîó',
              'Trees': 'üå≥',
              'Graphs': 'üï∏Ô∏è',
              'Dynamic Programming': '‚ö°',
              'Sorting': 'üì∂',
              'Searching': 'üîç',
              'Hash Tables': '#Ô∏è‚É£',
              'Stack': 'üìö',
              'Queue': 'üéØ',
              'Heap': 'üèîÔ∏è',
              'Backtracking': 'üîô',
              'Two Pointers': 'üëâüëà',
              'Sliding Window': 'ü™ü'
            };
            
            return topicEmojis[topic] ? `${topicEmojis[topic]} ${topic}` : topic;
          }

          function parseTableData(tableRows) {
            if (!tableRows || tableRows.length === 0) return { headers: [], data: [] };
            
            const headers = [];
            const data = [];
            let headerProcessed = false;
            
            for (const row of tableRows) {
              if (row.type === 'table_row' && row.table_row && row.table_row.cells) {
                const cells = row.table_row.cells.map(cell => formatRichText(cell).trim());
                
                if (!headerProcessed) {
                  // First row is header
                  headers.push(...cells);
                  headerProcessed = true;
                } else {
                  // Data rows
                  const rowData = {};
                  cells.forEach((cell, index) => {
                    if (index < headers.length) {
                      rowData[headers[index]] = cell;
                    }
                  });
                  
                  // Only include rows where "Done" column is checked (‚úÖ)
                  const doneValue = rowData['Done'] || '';
                  if (doneValue.includes('‚úÖ') || doneValue.toLowerCase().includes('true')) {
                    data.push(rowData);
                  }
                }
              }
            }
            
            return { headers, data };
          }

          async function syncNotion() {
            const token = process.env.NOTION_TOKEN;
            const pageId = process.env.NOTION_PAGE_ID || process.env.NOTION_DATABASE_ID;
            
            console.log('Environment check:');
            console.log('- NOTION_TOKEN exists:', !!token);
            console.log('- NOTION_PAGE_ID exists:', !!process.env.NOTION_PAGE_ID);
            console.log('- NOTION_DATABASE_ID exists:', !!process.env.NOTION_DATABASE_ID);
            console.log('- Using Page ID:', pageId ? pageId.substring(0, 8) + '...' : 'MISSING');
            
            if (!token) {
              console.error('‚ùå NOTION_TOKEN is missing or empty');
              process.exit(1);
            }
            
            if (!pageId) {
              console.error('‚ùå NOTION_PAGE_ID is missing or empty');
              console.error('üìã Please add NOTION_PAGE_ID to your GitHub repository secrets');
              console.error('üí° To find your page ID:');
              console.error('   1. Open your Notion page in browser');
              console.error('   2. Copy the URL');
              console.error('   3. Extract the 32-character ID from the URL');
              console.error('   Example: https://notion.so/myworkspace/Page-Name-abc123...xyz789');
              console.error('   Page ID would be: abc123...xyz789');
              process.exit(1);
            }

            try {
              console.log('Fetching Notion page content...');
              
              // Get all blocks from the page
              let allBlocks = [];
              let hasMore = true;
              let startCursor = null;

              while (hasMore) {
                const response = await getNotionBlocks(pageId, token, startCursor);
                
                if (response.results) {
                  allBlocks = allBlocks.concat(response.results);
                  hasMore = response.has_more;
                  startCursor = response.next_cursor;
                } else {
                  console.error('Error fetching blocks:', response);
                  process.exit(1);
                }
              }

              console.log(`Found ${allBlocks.length} blocks on the page`);

              // Find table blocks
              let tableData = { headers: [], data: [] };
              
              for (const block of allBlocks) {
                if (block.type === 'table') {
                  console.log('Found table block, fetching rows...');
                  const tableRows = await getChildBlocks(block.id, token);
                  if (tableRows.results) {
                    tableData = parseTableData(tableRows.results);
                    console.log(`Found ${tableData.headers.length} columns and ${tableData.data.length} completed rows`);
                    break; // Use the first table found
                  }
                }
              }

              if (tableData.data.length === 0) {
                console.log('No completed problems found in the table');
                return;
              }

              // Build the markdown output
              let markdown = '## üß† Blind 75 LeetCode Progress\n\n';
              
              // Add summary stats
              const totalCompleted = tableData.data.length;
              const difficultyStats = { easy: 0, medium: 0, hard: 0 };
              const topicStats = {};
              
              tableData.data.forEach(row => {
                const difficulty = (row['Difficulty'] || '').toLowerCase().trim();
                const topic = row['Topic'] || '';
                
                if (difficulty && difficultyStats.hasOwnProperty(difficulty)) {
                  difficultyStats[difficulty]++;
                }
                
                if (topic) {
                  topicStats[topic] = (topicStats[topic] || 0) + 1;
                }
              });

              markdown += `**Progress:** ${totalCompleted}/75 problems completed (${Math.round(totalCompleted/75*100)}%)\n\n`;
              markdown += `**By Difficulty:** üü¢ ${difficultyStats.easy} Easy | üü° ${difficultyStats.medium} Medium | üî¥ ${difficultyStats.hard} Hard\n\n`;

              // Create the table with original headers but make some more concise
              const displayHeaders = tableData.headers.map(header => {
                switch(header) {
                  case 'Problem Name & Link': return 'Problem';
                  case 'Time & Space Complexity': return 'Complexity';
                  case 'Date Edited / Completed': return 'Date';
                  default: return header;
                }
              });

              markdown += '| ' + displayHeaders.join(' | ') + ' |\n';
              markdown += '| ' + displayHeaders.map(() => '---').join(' | ') + ' |\n';

              // Add data rows
              tableData.data.forEach(row => {
                const rowData = tableData.headers.map(header => {
                  let value = row[header] || '';
                  
                  // Special formatting for specific columns
                  if (header === 'Difficulty' && value) {
                    value = getDifficultyBadge(value);
                  } else if (header === 'Topic' && value) {
                    value = getTopicBadge(value);
                  } else if (header === 'Languages' && value) {
                    // Format language tags nicely
                    value = value.split(',').map(lang => `\`${lang.trim()}\``).join(' ');
                  } else if (header.includes('Problem') && value && value.length > 30 && !value.includes('[')) {
                    // Truncate very long problem names if they're not already links
                    value = value.substring(0, 27) + '...';
                  }
                  
                  // Escape pipe characters and handle empty values
                  return value.replace(/\|/g, '\\|') || '-';
                });
                
                markdown += '| ' + rowData.join(' | ') + ' |\n';
              });

              // Add metadata
              const now = new Date();
              const lastUpdated = now.toLocaleString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: 'numeric',
                minute: '2-digit',
                hour12: true,
                timeZone: 'America/New_York'
              });
              
              markdown += `\n---\n\n*üìÖ Last synced: ${lastUpdated} EST*\n`;
              markdown += `*üéØ Keep grinding! You're ${Math.round((75-totalCompleted)/75*100)}% away from completing all 75 problems.*\n`;

              // Read existing README or create new one
              let readme = '';
              if (fs.existsSync('README.md')) {
                readme = fs.readFileSync('README.md', 'utf8');
              } else {
                readme = '# Welcome to my GitHub Profile!\n\n';
              }

              // Update content between markers
              const startMarker = '<!-- NOTION-SYNC-START -->';
              const endMarker = '<!-- NOTION-SYNC-END -->';
              
              const startIndex = readme.indexOf(startMarker);
              const endIndex = readme.indexOf(endMarker);

              if (startIndex !== -1 && endIndex !== -1) {
                // Replace content between markers
                const before = readme.substring(0, startIndex + startMarker.length);
                const after = readme.substring(endIndex);
                readme = before + '\n\n' + markdown + '\n' + after;
              } else {
                // If markers don't exist, add them and content at the end
                readme += `\n\n${startMarker}\n\n${markdown}\n${endMarker}\n`;
              }

              fs.writeFileSync('README.md', readme);
              console.log('‚úÖ README updated successfully with completed LeetCode problems!');

            } catch (error) {
              console.error('‚ùå Error syncing Notion:', error.message);
              if (error.response) {
                console.error('Response:', error.response);
              }
              process.exit(1);
            }
          }

          syncNotion();
          EOF
          
      - name: Sync Notion content
        env:
          NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}
          NOTION_DATABASE_ID: ${{ secrets.NOTION_DATABASE_ID }}
          NOTION_PAGE_ID: ${{ secrets.NOTION_PAGE_ID }}
        run: node sync-notion.js
        
      - name: Commit and push changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add README.md
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "üîÑ Auto-sync LeetCode progress - $(date '+%Y-%m-%d %H:%M')"
            git push
            echo "‚úÖ Changes pushed to repository"
          fi

# .github/workflows/notion-sync.yml
name: Sync Notion to README

on:
  schedule:
    - cron: '0 */6 * * *'  # Every 6 hours
  workflow_dispatch:  # Manual trigger button
  push:
    paths:
      - '.github/workflows/notion-sync.yml'  # Run when workflow is updated

jobs:
  sync-notion:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Create sync script
        run: |
          cat > sync-notion.js << 'EOF'
          const https = require('https');
          const fs = require('fs');

          function makeRequest(options, postData = null) {
            return new Promise((resolve, reject) => {
              const req = https.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => data += chunk);
                res.on('end', () => {
                  try {
                    resolve(JSON.parse(data));
                  } catch (e) {
                    resolve(data);
                  }
                });
              });
              req.on('error', reject);
              if (postData) req.write(JSON.stringify(postData));
              req.end();
            });
          }

          async function getNotionBlocks(pageId, token, startCursor = null) {
            const options = {
              hostname: 'api.notion.com',
              port: 443,
              path: `/v1/blocks/${pageId}/children${startCursor ? `?start_cursor=${startCursor}` : ''}`,
              method: 'GET',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Notion-Version': '2022-06-28',
                'Content-Type': 'application/json'
              }
            };

            return await makeRequest(options);
          }

          function formatRichText(richText) {
            return richText.map(text => {
              let content = text.plain_text;
              if (text.annotations.bold) content = `**${content}**`;
              if (text.annotations.italic) content = `*${content}*`;
              if (text.annotations.code) content = `\`${content}\``;
              if (text.annotations.strikethrough) content = `~~${content}~~`;
              if (text.href) content = `[${content}](${text.href})`;
              return content;
            }).join('');
          }

          async function getChildBlocks(blockId, token) {
            const options = {
              hostname: 'api.notion.com',
              port: 443,
              path: `/v1/blocks/${blockId}/children`,
              method: 'GET',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Notion-Version': '2022-06-28',
                'Content-Type': 'application/json',
                'User-Agent': 'GitHub-Action-Sync'
              }
            };
            return await makeRequest(options);
          }

          async function queryDatabase(databaseId, token) {
            const options = {
              hostname: 'api.notion.com',
              port: 443,
              path: `/v1/databases/${databaseId}/query`,
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Notion-Version': '2022-06-28',
                'Content-Type': 'application/json',
                'User-Agent': 'GitHub-Action-Sync'
              }
            };
            
            const requestBody = {
              filter: {
                and: []
              },
              sorts: []
            };
            
            return await makeRequest(options, requestBody);
          }

          async function getDatabaseSchema(databaseId, token) {
            const options = {
              hostname: 'api.notion.com',
              port: 443,
              path: `/v1/databases/${databaseId}`,
              method: 'GET',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Notion-Version': '2022-06-28',
                'Content-Type': 'application/json',
                'User-Agent': 'GitHub-Action-Sync'
              }
            };
            return await makeRequest(options);
          }

          function formatPropertyValue(property) {
            if (!property) return '';
            
            switch (property.type) {
              case 'title':
                return property.title.map(t => t.plain_text).join('').trim();
              case 'rich_text':
                return property.rich_text.map(t => t.plain_text).join('').trim();
              case 'number':
                return property.number ? property.number.toString() : '';
              case 'select':
                return property.select ? property.select.name : '';
              case 'multi_select':
                return property.multi_select.map(s => s.name).join(', ');
              case 'date':
                return property.date ? property.date.start : '';
              case 'checkbox':
                return property.checkbox ? '‚úÖ' : '‚ùå';
              case 'url':
                return property.url ? `[Link](${property.url})` : '';
              case 'email':
                return property.email ? `[${property.email}](mailto:${property.email})` : '';
              case 'phone_number':
                return property.phone_number || '';
              case 'status':
                return property.status ? property.status.name : '';
              case 'formula':
                if (property.formula) {
                  switch (property.formula.type) {
                    case 'string':
                      return property.formula.string || '';
                    case 'number':
                      return property.formula.number ? property.formula.number.toString() : '';
                    case 'boolean':
                      return property.formula.boolean ? '‚úÖ' : '‚ùå';
                    case 'date':
                      return property.formula.date ? property.formula.date.start : '';
                    default:
                      return '';
                  }
                }
                return '';
              default:
                return '';
            }
          }

          function isRowEmpty(entry, propertyNames) {
            // Check if all important columns are empty (excluding auto-generated ones)
            return propertyNames.every(propName => {
              const value = formatPropertyValue(entry.properties[propName]);
              // Consider a row empty if all values are empty strings, just checkmarks, or just dashes
              return !value || value.trim() === '' || value === '‚ùå' || value === '-';
            });
          }

          async function convertBlockToMarkdown(block, token, depth = 0) {
            const indent = '  '.repeat(depth);
            
            switch (block.type) {
              case 'paragraph':
                if (!block.paragraph.rich_text || block.paragraph.rich_text.length === 0) {
                  return '\n';
                }
                return formatRichText(block.paragraph.rich_text) + '\n\n';
                
              case 'heading_1':
                return '# ' + formatRichText(block.heading_1.rich_text) + '\n\n';
                
              case 'heading_2':
                return '## ' + formatRichText(block.heading_2.rich_text) + '\n\n';
                
              case 'heading_3':
                return '### ' + formatRichText(block.heading_3.rich_text) + '\n\n';
                
              case 'bulleted_list_item':
                let bulletContent = indent + '- ' + formatRichText(block.bulleted_list_item.rich_text) + '\n';
                if (block.has_children) {
                  try {
                    const children = await getChildBlocks(block.id, token);
                    if (children.results) {
                      for (const child of children.results) {
                        bulletContent += await convertBlockToMarkdown(child, token, depth + 1);
                      }
                    }
                  } catch (error) {
                    console.log('Error getting bullet children:', error);
                  }
                }
                return bulletContent;
                
              case 'numbered_list_item':
                let numberedContent = indent + '1. ' + formatRichText(block.numbered_list_item.rich_text) + '\n';
                if (block.has_children) {
                  try {
                    const children = await getChildBlocks(block.id, token);
                    if (children.results) {
                      for (const child of children.results) {
                        numberedContent += await convertBlockToMarkdown(child, token, depth + 1);
                      }
                    }
                  } catch (error) {
                    console.log('Error getting numbered children:', error);
                  }
                }
                return numberedContent;
                
              case 'to_do':
                const checked = block.to_do.checked ? '[x]' : '[ ]';
                return indent + `- ${checked} ` + formatRichText(block.to_do.rich_text) + '\n';
                
              case 'toggle':
                let toggleContent = '### ' + formatRichText(block.toggle.rich_text) + '\n\n';
                if (block.has_children) {
                  try {
                    const children = await getChildBlocks(block.id, token);
                    if (children.results) {
                      for (const child of children.results) {
                        toggleContent += await convertBlockToMarkdown(child, token, depth);
                      }
                    }
                  } catch (error) {
                    console.log('Error getting toggle children:', error);
                  }
                }
                return toggleContent;
                
              case 'code':
                const language = block.code.language || '';
                const codeText = formatRichText(block.code.rich_text);
                return `\`\`\`${language}\n${codeText}\n\`\`\`\n\n`;
                
              case 'quote':
                return '> ' + formatRichText(block.quote.rich_text) + '\n\n';
                
              case 'callout':
                const emoji = block.callout.icon?.emoji || 'üí°';
                return `${emoji} **${formatRichText(block.callout.rich_text)}**\n\n`;
                
              case 'divider':
                return '---\n\n';
                
              case 'table':
                try {
                  const tableData = await getChildBlocks(block.id, token);
                  if (!tableData.results || tableData.results.length === 0) {
                    return '**[Empty Table]**\n\n';
                  }
                  
                  let tableMarkdown = '';
                  const rows = tableData.results.filter(row => row.type === 'table_row');
                  
                  if (rows.length === 0) return '**[Empty Table]**\n\n';
                  
                  // Get column count from first row
                  const columnCount = rows[0].table_row?.cells?.length || 0;
                  if (columnCount === 0) return '**[Empty Table]**\n\n';
                  
                  let headerProcessed = false;
                  
                  for (const row of rows) {
                    if (row.table_row && row.table_row.cells) {
                      const cells = row.table_row.cells.map(cell => {
                        const cellText = formatRichText(cell).replace(/\|/g, '\\|').trim();
                        return cellText || ' ';
                      });
                      
                      // Check if row is empty (all cells are empty or just spaces)
                      const hasContent = cells.some(cell => cell.trim() && cell !== ' ');
                      
                      if (hasContent) {
                        // Ensure we have the right number of columns
                        while (cells.length < columnCount) cells.push(' ');
                        
                        tableMarkdown += '| ' + cells.join(' | ') + ' |\n';
                        
                        // Add separator after first non-empty row (header)
                        if (!headerProcessed) {
                          const separators = cells.map(() => '---');
                          tableMarkdown += '| ' + separators.join(' | ') + ' |\n';
                          headerProcessed = true;
                        }
                      }
                    }
                  }
                  
                  return tableMarkdown + '\n';
                } catch (error) {
                  console.log('Error processing table:', error);
                  return '**[Table - Error loading content]**\n\n';
                }
                
              case 'child_database':
                try {
                  console.log('Processing database:', block.id);
                  
                  // Get database schema to preserve column order
                  const dbSchema = await getDatabaseSchema(block.id, token);
                  const dbData = await queryDatabase(block.id, token);
                  
                  if (!dbData.results || dbData.results.length === 0) {
                    return '**[Empty Database]**\n\n';
                  }
                  
                  let dbMarkdown = '';
                  const entries = dbData.results;
                  
                  // Get property names in the correct order from schema
                  let propertyNames = [];
                  if (dbSchema.properties) {
                    // Use the order from the database schema
                    propertyNames = Object.keys(dbSchema.properties);
                  } else if (entries[0] && entries[0].properties) {
                    // Fallback to first entry properties
                    propertyNames = Object.keys(entries[0].properties);
                  }
                  
                  if (propertyNames.length === 0) {
                    return '**[Database - No properties found]**\n\n';
                  }
                  
                  // Filter out completely empty rows
                  const nonEmptyEntries = entries.filter(entry => !isRowEmpty(entry, propertyNames));
                  
                  if (nonEmptyEntries.length === 0) {
                    return '**[Database - No data to display]**\n\n';
                  }
                  
                  // Create header with proper column names from schema
                  const headerNames = propertyNames.map(propName => {
                    // Get the display name from schema if available
                    if (dbSchema.properties && dbSchema.properties[propName]) {
                      return dbSchema.properties[propName].name || propName;
                    }
                    return propName;
                  });
                  
                  dbMarkdown += '| ' + headerNames.join(' | ') + ' |\n';
                  dbMarkdown += '| ' + propertyNames.map(() => '---').join(' | ') + ' |\n';
                  
                  // Add data rows (only non-empty ones)
                  for (const entry of nonEmptyEntries) {
                    const rowData = propertyNames.map(propName => {
                      const value = formatPropertyValue(entry.properties[propName]);
                      return value.replace(/\|/g, '\\|') || ' ';
                    });
                    dbMarkdown += '| ' + rowData.join(' | ') + ' |\n';
                  }
                  
                  return dbMarkdown + '\n';
                } catch (error) {
                  console.log('Error processing database:', error);
                  return '**[Database - Error loading content]**\n\n';
                }
                
              case 'column_list':
                try {
                  const columns = await getChildBlocks(block.id, token);
                  let columnContent = '';
                  
                  if (columns.results && columns.results.length > 0) {
                    // Process each column
                    for (let i = 0; i < columns.results.length; i++) {
                      const column = columns.results[i];
                      if (column.type === 'column') {
                        columnContent += `#### Column ${i + 1}\n\n`;
                        const columnBlocks = await getChildBlocks(column.id, token);
                        if (columnBlocks.results) {
                          for (const colBlock of columnBlocks.results) {
                            columnContent += await convertBlockToMarkdown(colBlock, token, depth);
                          }
                        }
                        columnContent += '\n';
                      }
                    }
                  }
                  
                  return columnContent;
                } catch (error) {
                  console.log('Error processing columns:', error);
                  return '**[Column Layout - Error loading content]**\n\n';
                }
                
              case 'embed':
                if (block.embed && block.embed.url) {
                  return `[üìé Embedded Content](${block.embed.url})\n\n`;
                }
                return '**[üìé Embedded content]**\n\n';
                
              case 'image':
                if (block.image && (block.image.file?.url || block.image.external?.url)) {
                  const imageUrl = block.image.file?.url || block.image.external?.url;
                  const caption = block.image.caption ? formatRichText(block.image.caption) : '';
                  return `![${caption}](${imageUrl})\n${caption ? `*${caption}*\n` : ''}\n`;
                }
                return '**[üñºÔ∏è Image]**\n\n';
                
              case 'bookmark':
                if (block.bookmark && block.bookmark.url) {
                  const caption = block.bookmark.caption ? formatRichText(block.bookmark.caption) : 'Bookmark';
                  return `[üîñ ${caption}](${block.bookmark.url})\n\n`;
                }
                return '**[üîñ Bookmark]**\n\n';
                
              default:
                // Handle any other block types gracefully
                if (block[block.type] && block[block.type].rich_text) {
                  return formatRichText(block[block.type].rich_text) + '\n\n';
                }
                console.log(`Unsupported block type: ${block.type}`);
                return `**[${block.type.replace('_', ' ').toUpperCase()}]**\n\n`;
            }
          }

          async function syncNotion() {
            const token = process.env.NOTION_TOKEN;
            const pageId = process.env.NOTION_PAGE_ID;
            
            if (!token || !pageId) {
              console.error('Missing NOTION_TOKEN or NOTION_PAGE_ID');
              process.exit(1);
            }

            try {
              console.log('Fetching Notion content...');
              let allBlocks = [];
              let hasMore = true;
              let startCursor = null;

              while (hasMore) {
                const response = await getNotionBlocks(pageId, token, startCursor);
                
                if (response.results) {
                  allBlocks = allBlocks.concat(response.results);
                  hasMore = response.has_more;
                  startCursor = response.next_cursor;
                } else {
                  console.error('Error fetching blocks:', response);
                  process.exit(1);
                }
              }

              let markdown = '';
              for (const block of allBlocks) {
                markdown += await convertBlockToMarkdown(block, token);
              }

              // Add metadata
              const now = new Date();
              const lastUpdated = now.toISOString().split('T')[0];
              markdown += `\n---\n\n*üìÖ Last synced: ${lastUpdated}*\n`;

              // Read existing README or create new one
              let readme = '';
              if (fs.existsSync('README.md')) {
                readme = fs.readFileSync('README.md', 'utf8');
              } else {
                readme = '# Welcome to my GitHub Profile!\n\n';
              }

              // Update content between markers
              const startMarker = '<!-- NOTION-SYNC-START -->';
              const endMarker = '<!-- NOTION-SYNC-END -->';
              
              const startIndex = readme.indexOf(startMarker);
              const endIndex = readme.indexOf(endMarker);

              if (startIndex !== -1 && endIndex !== -1) {
                // Replace ONLY the content between markers
                const before = readme.substring(0, startIndex + startMarker.length);
                const after = readme.substring(endIndex);
                readme = before + '\n\n' + markdown + '\n' + after;
              } else {
                // If markers don't exist, add them and content at the end
                readme += `\n\n## üß† Blind 75 LeetCode Progress\n\n${startMarker}\n\n${markdown}\n${endMarker}\n`;
              }

              fs.writeFileSync('README.md', readme);
              console.log('‚úÖ README updated successfully!');

            } catch (error) {
              console.error('‚ùå Error syncing Notion:', error.message);
              process.exit(1);
            }
          }

          syncNotion();
          EOF
          
      - name: Sync Notion content
        env:
          NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}
          NOTION_PAGE_ID: ${{ secrets.NOTION_PAGE_ID }}
        run: node sync-notion.js
        
      - name: Commit and push changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add README.md
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "üîÑ Auto-sync Notion content - $(date '+%Y-%m-%d %H:%M')"
            git push
            echo "‚úÖ Changes pushed to repository"
          fi

# .github/workflows/notion-sync.yml
name: Sync Notion to README

on:
  schedule:
    - cron: '0 */6 * * *'  # Every 6 hours
  workflow_dispatch:  # Manual trigger button
  push:
    paths:
      - '.github/workflows/notion-sync.yml'  # Run when workflow is updated

jobs:
  sync-notion:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Create sync script
        run: |
          cat > sync-notion.js << 'EOF'
          const https = require('https');
          const fs = require('fs');

          function makeRequest(options, postData = null) {
            return new Promise((resolve, reject) => {
              const req = https.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => data += chunk);
                res.on('end', () => {
                  try {
                    resolve(JSON.parse(data));
                  } catch (e) {
                    resolve(data);
                  }
                });
              });
              req.on('error', reject);
              if (postData) req.write(JSON.stringify(postData));
              req.end();
            });
          }

          async function queryDatabase(databaseId, token) {
            const options = {
              hostname: 'api.notion.com',
              port: 443,
              path: `/v1/databases/${databaseId}/query`,
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Notion-Version': '2022-06-28',
                'Content-Type': 'application/json',
                'User-Agent': 'GitHub-Action-Sync'
              }
            };
            
            const requestBody = {
              filter: {
                property: "Done",
                checkbox: {
                  equals: true
                }
              },
              sorts: [
                {
                  property: "Day",
                  direction: "ascending"
                }
              ]
            };
            
            return await makeRequest(options, requestBody);
          }

          async function getDatabaseSchema(databaseId, token) {
            const options = {
              hostname: 'api.notion.com',
              port: 443,
              path: `/v1/databases/${databaseId}`,
              method: 'GET',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Notion-Version': '2022-06-28',
                'Content-Type': 'application/json',
                'User-Agent': 'GitHub-Action-Sync'
              }
            };
            return await makeRequest(options);
          }

          function formatPropertyValue(property) {
            if (!property) return '';
            
            switch (property.type) {
              case 'title':
                return property.title.map(t => t.plain_text).join('').trim();
              case 'rich_text':
                return property.rich_text.map(t => {
                  let content = t.plain_text;
                  if (t.annotations.bold) content = `**${content}**`;
                  if (t.annotations.italic) content = `*${content}*`;
                  if (t.annotations.code) content = `\`${content}\``;
                  if (t.href) content = `[${content}](${t.href})`;
                  return content;
                }).join('').trim();
              case 'number':
                return property.number ? property.number.toString() : '';
              case 'select':
                return property.select ? property.select.name : '';
              case 'multi_select':
                return property.multi_select.map(s => s.name).join(', ');
              case 'date':
                if (property.date) {
                  const date = new Date(property.date.start);
                  return date.toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'short', 
                    day: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit',
                    hour12: true
                  });
                }
                return '';
              case 'checkbox':
                return property.checkbox ? '‚úÖ' : '‚ùå';
              case 'url':
                return property.url ? `[Link](${property.url})` : '';
              case 'email':
                return property.email ? `[${property.email}](mailto:${property.email})` : '';
              case 'phone_number':
                return property.phone_number || '';
              case 'status':
                return property.status ? property.status.name : '';
              case 'formula':
                if (property.formula) {
                  switch (property.formula.type) {
                    case 'string':
                      return property.formula.string || '';
                    case 'number':
                      return property.formula.number ? property.formula.number.toString() : '';
                    case 'boolean':
                      return property.formula.boolean ? '‚úÖ' : '‚ùå';
                    case 'date':
                      return property.formula.date ? property.formula.date.start : '';
                    default:
                      return '';
                  }
                }
                return '';
              default:
                return '';
            }
          }

          function getDifficultyBadge(difficulty) {
            switch(difficulty.toLowerCase()) {
              case 'easy':
                return 'üü¢ Easy';
              case 'medium':
                return 'üü° Medium';
              case 'hard':
                return 'üî¥ Hard';
              default:
                return difficulty;
            }
          }

          function getTopicBadge(topic) {
            const topicEmojis = {
              'Arrays': 'üìä',
              'Strings': 'üî§',
              'Linked Lists': 'üîó',
              'Trees': 'üå≥',
              'Graphs': 'üï∏Ô∏è',
              'Dynamic Programming': '‚ö°',
              'Sorting': 'üì∂',
              'Searching': 'üîç',
              'Hash Tables': '#Ô∏è‚É£',
              'Stack': 'üìö',
              'Queue': 'üéØ',
              'Heap': 'üèîÔ∏è',
              'Backtracking': 'üîô',
              'Two Pointers': 'üëâüëà',
              'Sliding Window': 'ü™ü'
            };
            
            return topicEmojis[topic] ? `${topicEmojis[topic]} ${topic}` : topic;
          }

          async function syncNotion() {
            const token = process.env.NOTION_TOKEN;
            const databaseId = process.env.NOTION_DATABASE_ID;
            
            if (!token || !databaseId) {
              console.error('Missing NOTION_TOKEN or NOTION_DATABASE_ID');
              process.exit(1);
            }

            try {
              console.log('Fetching completed LeetCode problems from Notion...');
              
              const dbData = await queryDatabase(databaseId, token);
              
              if (!dbData.results || dbData.results.length === 0) {
                console.log('No completed problems found');
                return;
              }

              console.log(`Found ${dbData.results.length} completed problems`);

              // Define the exact column order matching your table
              const columnOrder = [
                'Day',
                'Done', 
                'Problem Name & Link',
                'Topic',
                'Difficulty',
                'Time & Space Complexity',
                'Work',
                'Languages',
                'Date Edited / Completed'
              ];

              let markdown = '## üß† Blind 75 LeetCode Progress\n\n';
              
              // Add summary stats
              const totalCompleted = dbData.results.length;
              const topicStats = {};
              const difficultyStats = { easy: 0, medium: 0, hard: 0 };
              
              dbData.results.forEach(entry => {
                const topic = formatPropertyValue(entry.properties['Topic']);
                const difficulty = formatPropertyValue(entry.properties['Difficulty']).toLowerCase();
                
                if (topic) {
                  topicStats[topic] = (topicStats[topic] || 0) + 1;
                }
                
                if (difficulty && difficultyStats.hasOwnProperty(difficulty)) {
                  difficultyStats[difficulty]++;
                }
              });

              markdown += `**Progress:** ${totalCompleted}/75 problems completed (${Math.round(totalCompleted/75*100)}%)\n\n`;
              markdown += `**By Difficulty:** üü¢ ${difficultyStats.easy} Easy | üü° ${difficultyStats.medium} Medium | üî¥ ${difficultyStats.hard} Hard\n\n`;

              // Create the table header
              const headers = columnOrder.map(col => {
                // Make headers more concise for better table formatting
                switch(col) {
                  case 'Problem Name & Link': return 'Problem';
                  case 'Time & Space Complexity': return 'Complexity';
                  case 'Date Edited / Completed': return 'Date';
                  default: return col;
                }
              });

              markdown += '| ' + headers.join(' | ') + ' |\n';
              markdown += '| ' + headers.map(() => '---').join(' | ') + ' |\n';

              // Add data rows for completed problems only
              dbData.results.forEach(entry => {
                const rowData = columnOrder.map(colName => {
                  let value = formatPropertyValue(entry.properties[colName]);
                  
                  // Special formatting for specific columns
                  if (colName === 'Difficulty' && value) {
                    value = getDifficultyBadge(value);
                  } else if (colName === 'Topic' && value) {
                    value = getTopicBadge(value);
                  } else if (colName === 'Languages' && value) {
                    // Format language tags nicely
                    value = value.split(', ').map(lang => `\`${lang}\``).join(' ');
                  } else if (colName === 'Problem Name & Link' && value) {
                    // If it's a rich text field with a link, it should already be formatted
                    // Otherwise, truncate very long problem names
                    if (value.length > 30 && !value.includes('[')) {
                      value = value.substring(0, 27) + '...';
                    }
                  }
                  
                  // Escape pipe characters and handle empty values
                  return (value || '').replace(/\|/g, '\\|') || '-';
                });
                
                markdown += '| ' + rowData.join(' | ') + ' |\n';
              });

              // Add metadata
              const now = new Date();
              const lastUpdated = now.toLocaleString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: 'numeric',
                minute: '2-digit',
                hour12: true,
                timeZone: 'America/New_York'
              });
              
              markdown += `\n---\n\n*üìÖ Last synced: ${lastUpdated} EST*\n`;
              markdown += `*üéØ Keep grinding! You're ${Math.round((75-totalCompleted)/75*100)}% away from completing all 75 problems.*\n`;

              // Read existing README or create new one
              let readme = '';
              if (fs.existsSync('README.md')) {
                readme = fs.readFileSync('README.md', 'utf8');
              } else {
                readme = '# Welcome to my GitHub Profile!\n\n';
              }

              // Update content between markers
              const startMarker = '<!-- NOTION-SYNC-START -->';
              const endMarker = '<!-- NOTION-SYNC-END -->';
              
              const startIndex = readme.indexOf(startMarker);
              const endIndex = readme.indexOf(endMarker);

              if (startIndex !== -1 && endIndex !== -1) {
                // Replace content between markers
                const before = readme.substring(0, startIndex + startMarker.length);
                const after = readme.substring(endIndex);
                readme = before + '\n\n' + markdown + '\n' + after;
              } else {
                // If markers don't exist, add them and content at the end
                readme += `\n\n${startMarker}\n\n${markdown}\n${endMarker}\n`;
              }

              fs.writeFileSync('README.md', readme);
              console.log('‚úÖ README updated successfully with completed LeetCode problems!');

            } catch (error) {
              console.error('‚ùå Error syncing Notion:', error.message);
              if (error.response) {
                console.error('Response:', error.response);
              }
              process.exit(1);
            }
          }

          syncNotion();
          EOF
          
      - name: Sync Notion content
        env:
          NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}
          NOTION_DATABASE_ID: ${{ secrets.NOTION_DATABASE_ID }}
        run: node sync-notion.js
        
      - name: Commit and push changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add README.md
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "üîÑ Auto-sync LeetCode progress - $(date '+%Y-%m-%d %H:%M')"
            git push
            echo "‚úÖ Changes pushed to repository"
          fi

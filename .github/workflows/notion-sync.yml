# .github/workflows/notion-sync.yml
name: Sync Notion to README

on:
  schedule:
    - cron: '0 */6 * * *'  # Every 6 hours
  workflow_dispatch:  # Manual trigger button
  push:
    paths:
      - '.github/workflows/notion-sync.yml'  # Run when workflow is updated

jobs:
  sync-notion:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Create sync script
        run: |
          cat > sync-notion.js << 'EOF'
          const https = require('https');
          const fs = require('fs');

          function makeRequest(options, postData = null) {
            return new Promise((resolve, reject) => {
              const req = https.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => data += chunk);
                res.on('end', () => {
                  try {
                    resolve(JSON.parse(data));
                  } catch (e) {
                    resolve(data);
                  }
                });
              });
              req.on('error', reject);
              if (postData) req.write(JSON.stringify(postData));
              req.end();
            });
          }

          async function getNotionBlocks(pageId, token, startCursor = null) {
            const options = {
              hostname: 'api.notion.com',
              port: 443,
              path: `/v1/blocks/${pageId}/children${startCursor ? `?start_cursor=${startCursor}` : ''}`,
              method: 'GET',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Notion-Version': '2022-06-28',
                'Content-Type': 'application/json'
              }
            };

            return await makeRequest(options);
          }

          async function getChildBlocks(blockId, token) {
            const options = {
              hostname: 'api.notion.com',
              port: 443,
              path: `/v1/blocks/${blockId}/children`,
              method: 'GET',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Notion-Version': '2022-06-28',
                'Content-Type': 'application/json',
                'User-Agent': 'GitHub-Action-Sync'
              }
            };
            return await makeRequest(options);
          }

          function formatRichText(richText) {
            if (!richText || !Array.isArray(richText)) return '';
            return richText.map(text => {
              let content = text.plain_text;
              if (text.annotations.bold) content = `**${content}**`;
              if (text.annotations.italic) content = `*${content}*`;
              if (text.annotations.code) content = `\`${content}\``;
              if (text.annotations.strikethrough) content = `~~${content}~~`;
              if (text.href) content = `[${content}](${text.href})`;
              return content;
            }).join('');
          }

          function getDifficultyBadge(difficulty) {
            const difficultyStr = difficulty.toLowerCase().trim();
            switch(difficultyStr) {
              case 'easy':
                return 'üü¢ Easy';
              case 'medium':
                return 'üü° Medium';
              case 'hard':
                return 'üî¥ Hard';
              default:
                return difficulty;
            }
          }

          function getTopicBadge(topic) {
            const topicEmojis = {
              'Arrays': 'üìä',
              'Strings': 'üî§',
              'Linked Lists': 'üîó',
              'Trees': 'üå≥',
              'Graphs': 'üï∏Ô∏è',
              'Dynamic Programming': '‚ö°',
              'Sorting': 'üì∂',
              'Searching': 'üîç',
              'Hash Tables': '#Ô∏è‚É£',
              'Stack': 'üìö',
              'Queue': 'üéØ',
              'Heap': 'üèîÔ∏è',
              'Backtracking': 'üîô',
              'Two Pointers': 'üëâüëà',
              'Sliding Window': 'ü™ü'
            };
            
            return topicEmojis[topic] ? `${topicEmojis[topic]} ${topic}` : topic;
          }

          function parseTableData(tableRows) {
            if (!tableRows || tableRows.length === 0) return { headers: [], data: [] };
            
            const headers = [];
            const data = [];
            let headerProcessed = false;
            
            console.log(`Parsing ${tableRows.length} table rows...`);
            
            for (let i = 0; i < tableRows.length; i++) {
              const row = tableRows[i];
              console.log(`Processing row ${i}: type = ${row.type}`);
              
              if (row.type === 'table_row' && row.table_row && row.table_row.cells) {
                const cells = row.table_row.cells.map(cell => formatRichText(cell).trim());
                console.log(`Row ${i} cells:`, cells);
                
                if (!headerProcessed) {
                  // First row is header
                  headers.push(...cells);
                  headerProcessed = true;
                  console.log('‚úÖ Table headers found:', headers);
                } else {
                  // Data rows
                  const rowData = {};
                  cells.forEach((cell, index) => {
                    if (index < headers.length) {
                      rowData[headers[index]] = cell;
                    }
                  });
                  
                  console.log(`Row ${i} data:`, rowData);
                  
                  // Look for Done column in different possible positions and names
                  let doneValue = '';
                  let doneFound = false;
                  
                  // Try different variations of the Done column
                  for (const header of headers) {
                    if (header.toLowerCase().includes('done') || 
                        header.toLowerCase().includes('completed') ||
                        header.toLowerCase().includes('check')) {
                      doneValue = rowData[header] || '';
                      doneFound = true;
                      console.log(`Found Done column "${header}" with value: "${doneValue}"`);
                      break;
                    }
                  }
                  
                  if (!doneFound) {
                    // Try by position - Done might be in a specific column
                    console.log('No Done column found by name, checking all cells for checkmarks...');
                    cells.forEach((cell, idx) => {
                      console.log(`Cell ${idx} (${headers[idx] || 'unknown'}): "${cell}"`);
                      if (cell.includes('‚úÖ') || cell.includes('‚òë') || cell.includes('‚úì') || 
                          cell === 'true' || cell.toLowerCase() === 'yes') {
                        doneValue = cell;
                        doneFound = true;
                        console.log(`Found checkmark in column ${idx}: "${cell}"`);
                      }
                    });
                  }
                  
                  // Check for actual checkmark symbols or "true" values
                  if (doneValue.includes('‚úÖ') || doneValue.includes('‚òë') || 
                      doneValue.includes('‚úì') || doneValue === 'true' ||
                      doneValue.toLowerCase() === 'yes') {
                    console.log('‚úÖ Including completed row');
                    data.push(rowData);
                  } else {
                    console.log('‚ùå Skipping uncompleted row');
                  }
                }
              }
            }
            
            console.log(`Final result: ${headers.length} headers, ${data.length} completed rows`);
            return { headers, data };
          }

          async function syncNotion() {
            const token = process.env.NOTION_TOKEN;
            const pageId = process.env.NOTION_PAGE_ID || process.env.NOTION_DATABASE_ID;
            
            console.log('Environment check:');
            console.log('- NOTION_TOKEN exists:', !!token);
            console.log('- NOTION_PAGE_ID exists:', !!process.env.NOTION_PAGE_ID);
            console.log('- NOTION_DATABASE_ID exists:', !!process.env.NOTION_DATABASE_ID);
            console.log('- Using Page ID:', pageId ? pageId.substring(0, 8) + '...' : 'MISSING');
            
            if (!token) {
              console.error('‚ùå NOTION_TOKEN is missing or empty');
              process.exit(1);
            }
            
            if (!pageId) {
              console.error('‚ùå NOTION_PAGE_ID is missing or empty');
              console.error('üìã Please add NOTION_PAGE_ID to your GitHub repository secrets');
              console.error('üí° To find your page ID:');
              console.error('   1. Open your Notion page in browser');
              console.error('   2. Copy the URL');
              console.error('   3. Extract the 32-character ID from the URL');
              console.error('   Example: https://notion.so/myworkspace/Page-Name-abc123...xyz789');
              console.error('   Page ID would be: abc123...xyz789');
              process.exit(1);
            }

            try {
              console.log('Fetching Notion page content...');
              
              // Get all blocks from the page
              let allBlocks = [];
              let hasMore = true;
              let startCursor = null;

              while (hasMore) {
                const response = await getNotionBlocks(pageId, token, startCursor);
                
                if (response.results) {
                  allBlocks = allBlocks.concat(response.results);
                  hasMore = response.has_more;
                  startCursor = response.next_cursor;
                } else {
                  console.error('Error fetching blocks:', response);
                  process.exit(1);
                }
              }

              console.log(`Found ${allBlocks.length} blocks on the page`);

              // Find table blocks
              let tableData = { headers: [], data: [] };
              
              console.log('Searching for table in blocks...');
              for (let i = 0; i < allBlocks.length; i++) {
                const block = allBlocks[i];
                console.log(`Block ${i}: type = ${block.type}`);
                
                if (block.type === 'table') {
                  console.log('‚úÖ Found table block, fetching rows...');
                  const tableRows = await getChildBlocks(block.id, token);
                  console.log(`Table has ${tableRows.results?.length || 0} rows`);
                  
                  if (tableRows.results && tableRows.results.length > 0) {
                    // Log first few rows to see the structure
                    console.log('First 3 table rows structure:');
                    tableRows.results.slice(0, 3).forEach((row, idx) => {
                      if (row.type === 'table_row' && row.table_row?.cells) {
                        const cells = row.table_row.cells.map(cell => formatRichText(cell).trim());
                        console.log(`Row ${idx}:`, cells);
                      }
                    });
                    
                    tableData = parseTableData(tableRows.results);
                    console.log(`‚úÖ Parsed table: ${tableData.headers.length} columns, ${tableData.data.length} completed rows`);
                    break; // Use the first table found
                  }
                } else if (block.type === 'child_database') {
                  console.log('Found child database block - this might be your table');
                  // Handle embedded databases too
                  try {
                    const dbData = await getChildBlocks(block.id, token);
                    console.log('Database child blocks:', dbData.results?.length || 0);
                  } catch (error) {
                    console.log('Error accessing child database:', error.message);
                  }
                }
              }

              if (tableData.data.length === 0) {
                console.log('No completed problems found in the table');
                return;
              }

              // Build the markdown output
              let markdown = '## üß† Blind 75 LeetCode Progress\n\n';
              
              // Add summary stats
              const totalCompleted = tableData.data.length;
              const difficultyStats = { easy: 0, medium: 0, hard: 0 };
              const topicStats = {};
              
              tableData.data.forEach(row => {
                const difficulty = (row['Difficulty'] || '').toLowerCase().trim();
                const topic = row['Topic'] || '';
                
                if (difficulty && difficultyStats.hasOwnProperty(difficulty)) {
                  difficultyStats[difficulty]++;
                }
                
                if (topic) {
                  topicStats[topic] = (topicStats[topic] || 0) + 1;
                }
              });

              markdown += `**Progress:** ${totalCompleted}/75 problems completed (${Math.round(totalCompleted/75*100)}%)\n\n`;
              markdown += `**By Difficulty:** üü¢ ${difficultyStats.easy} Easy | üü° ${difficultyStats.medium} Medium | üî¥ ${difficultyStats.hard} Hard\n\n`;

              // Define the desired column order for display (only the important ones)
              const desiredColumns = [
                'Problem Name & Link',
                'Topic', 
                'Difficulty',
                'Time & Space Complexity',
                'Languages',
                'Date Edited / Completed'
              ];

              // Map original headers to desired columns (handle variations in naming)
              const columnMapping = {};
              tableData.headers.forEach(header => {
                const cleanHeader = header.trim();
                if (cleanHeader.toLowerCase().includes('problem')) {
                  columnMapping['Problem Name & Link'] = cleanHeader;
                } else if (cleanHeader.toLowerCase().includes('topic')) {
                  columnMapping['Topic'] = cleanHeader;
                } else if (cleanHeader.toLowerCase().includes('difficulty')) {
                  columnMapping['Difficulty'] = cleanHeader;
                } else if (cleanHeader.toLowerCase().includes('complexity') || cleanHeader.toLowerCase().includes('time')) {
                  columnMapping['Time & Space Complexity'] = cleanHeader;
                } else if (cleanHeader.toLowerCase().includes('language')) {
                  columnMapping['Languages'] = cleanHeader;
                } else if (cleanHeader.toLowerCase().includes('date')) {
                  columnMapping['Date Edited / Completed'] = cleanHeader;
                }
              });

              console.log('Column mapping:', columnMapping);

              // Create display headers (shortened for better formatting)
              const displayHeaders = desiredColumns.map(col => {
                switch(col) {
                  case 'Problem Name & Link': return 'Problem';
                  case 'Time & Space Complexity': return 'Complexity';
                  case 'Date Edited / Completed': return 'Date';
                  default: return col;
                }
              }).filter(header => {
                // Only include columns that exist in the original table
                const originalCol = desiredColumns.find(col => {
                  const mappedHeader = columnMapping[col];
                  return mappedHeader && tableData.headers.includes(mappedHeader);
                });
                return !!originalCol;
              });

              // Create the actual column keys we'll use
              const actualColumns = desiredColumns.filter(col => columnMapping[col]);

              if (actualColumns.length === 0) {
                console.log('No matching columns found. Available headers:', tableData.headers);
                return;
              }

              markdown += '| ' + displayHeaders.join(' | ') + ' |\n';
              markdown += '| ' + displayHeaders.map(() => '---').join(' | ') + ' |\n';

              // Add data rows (only completed ones)
              tableData.data.forEach(row => {
                const rowData = actualColumns.map(col => {
                  const originalHeader = columnMapping[col];
                  let value = row[originalHeader] || '';
                  
                  // Special formatting for specific columns
                  if (col === 'Difficulty' && value) {
                    value = getDifficultyBadge(value);
                  } else if (col === 'Topic' && value) {
                    value = getTopicBadge(value);
                  } else if (col === 'Languages' && value) {
                    // Format language tags nicely
                    value = value.split(',').map(lang => `\`${lang.trim()}\``).join(' ');
                  } else if (col.includes('Problem') && value && value.length > 35 && !value.includes('[')) {
                    // Truncate very long problem names if they're not already links
                    value = value.substring(0, 32) + '...';
                  }
                  
                  // Escape pipe characters and handle empty values
                  return value.replace(/\|/g, '\\|') || '-';
                });
                
                markdown += '| ' + rowData.join(' | ') + ' |\n';
              });

              // Add metadata
              const now = new Date();
              const lastUpdated = now.toLocaleString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: 'numeric',
                minute: '2-digit',
                hour12: true,
                timeZone: 'America/New_York'
              });
              
              markdown += `\n---\n\n*üìÖ Last synced: ${lastUpdated} EST*\n`;
              markdown += `*üéØ Keep grinding! You're ${Math.round((75-totalCompleted)/75*100)}% away from completing all 75 problems.*\n`;

              // Read existing README or create new one
              let readme = '';
              if (fs.existsSync('README.md')) {
                readme = fs.readFileSync('README.md', 'utf8');
              } else {
                readme = '# Welcome to my GitHub Profile!\n\n';
              }

              // Update content between markers
              const startMarker = '<!-- NOTION-SYNC-START -->';
              const endMarker = '<!-- NOTION-SYNC-END -->';
              
              const startIndex = readme.indexOf(startMarker);
              const endIndex = readme.indexOf(endMarker);

              if (startIndex !== -1 && endIndex !== -1) {
                // Replace content between markers
                const before = readme.substring(0, startIndex + startMarker.length);
                const after = readme.substring(endIndex);
                readme = before + '\n\n' + markdown + '\n' + after;
              } else {
                // If markers don't exist, add them and content at the end
                readme += `\n\n${startMarker}\n\n${markdown}\n${endMarker}\n`;
              }

              fs.writeFileSync('README.md', readme);
              console.log('‚úÖ README updated successfully with completed LeetCode problems!');

            } catch (error) {
              console.error('‚ùå Error syncing Notion:', error.message);
              if (error.response) {
                console.error('Response:', error.response);
              }
              process.exit(1);
            }
          }

          syncNotion();
          EOF
          
      - name: Sync Notion content
        env:
          NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}
          NOTION_DATABASE_ID: ${{ secrets.NOTION_DATABASE_ID }}
          NOTION_PAGE_ID: ${{ secrets.NOTION_PAGE_ID }}
        run: node sync-notion.js
        
      - name: Commit and push changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add README.md
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "üîÑ Auto-sync LeetCode progress - $(date '+%Y-%m-%d %H:%M')"
            git push
            echo "‚úÖ Changes pushed to repository"
          fi
